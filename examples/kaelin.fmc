// # Kaelin 
// 
// A simple MOBA-like boardgame and a showcase for Formality-Core
// 
// It aims to be blockchain-compatible. That means real-time Kaelin matches can
// take place inside smart-contract platforms like Ethereum or Tezos. That's
// because turns have 10-20 seconds, and moves are made in a commit-reveal
// scheme, allowing the game state to be computed by players directly, without
// a central server (aka state-channels). In the case of a dispute (such as a
// player stopping to respond), the blockchain can be consulted and resolve the
// conflict in an acceptable time (about 1 minute).
// 
// Kaelin aims to preserve many of the fun characteristics of a MOBA such as
// map control, micro and macro decisions, team-work, and essentially answer
// the question: how do you dodge a skillshot in a turn-based boardgame?
// 
// ## Heroes
// 
// Name    | Role       | Description    | MOV | HP  | References & Inspiration
// ------- | ---------- | -------------- | --- | --- | -------------------------------------------------
// Tophoro | Tank       | Terrain Bender |   2 | 120 | Toph (Avatar TLA), Totoro (Studio Ghibli)
// Gonk    | Tank       | Warrior        |   2 |  90 | Gon (Hunter X Hunter), Goku (Gradon Ball Z)
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// Erkos   | Ranged     | Fire Mage      |   3 |  40 | Erk (Fire Emblem), Harry Potter (Harry Potter)
// Croni   | Ranged     | Dark Mage      |   3 |  40 | Chromie (Blizzard), Raven (Teen Titans)
// Snarch  | Ranged     | Archer         |   3 |  60 | Zk-Snarks (crypto)
// ?       | Ranged     | ?              |   ? |   ? | ?
// ?       | Ranged     | ?              |   ? |   ? | ?
// ?       | Ranged     | ?              |   ? |   ? | ?
// Sirpix  | Melee      | Thief          |   3 |  60 | Dev
// Kenlua  | Melee      | Swordsman      |   4 |  60 | Killua (Hunter X Hunter), Kenshin (Rurouni Kenshin)
// Flina   | Melee      | Pegasus Knight |   4 |  60 | Florina (Fire Emblem), Link (The Legend of Zelda)
// ?       | Melee      | ?              |   ? |   ? | ?
// ?       | Melee      | ?              |   ? |   ? | ?
// ?       | Melee      | ?              |   ? |   ? | ?
// Stanci  | Support    | Healer         |   3 |  40 | Dev
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// Zagatur | Influencer | Summoner       |   0 |  10 | Zagara, Abathur (Blizzard)
// Agdris  | Influencer | Silencer       |   1 |  20 | Agda, Idris (programming language)
// Mewru   | Influencer | Psychic        |   0 |  20 | Mewtwo (Pok√©mon), Meruem (Hunter X Hunter)
// ?       | Influencer | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
//
// ## Moves
// 
// - Tophoro
//   - Earth Lock : selects an enemy in a 5x5 (circle) around. Stuns him/her. Can't use Earth Lock on next turn.
//   - Earth Pull : pulls enemies in a 1-3-5 (wave) ahead.
//   - Earth Wall : creates up to 3 earth walls in a 5x5 (circle) around.
//   - Earth Slam : slams enemies in a 3x3 (square) around, stunning him/her.
//   - Earth Root : self-roots for 3 turns, gaining massive shield and heal.
// 
// - Gonk
//   - Endure  : can't die on this turn, staying at 1 HP minimum. Can't attack on this turn. Can't use for more than 3 consecutive turns.
//   - Breath  : heals 9 HP. Can't move on this turn. 
//   - Empathy : allies in a 5x5 range can't take damage during this turn. Gonk takes all damage they would take.
//   - Counter : select an enemy up to 5 range. If he/she damages Gonk directly during this turn, he/she takes the damage instead.
//   - Shatter : select an enemy up to 1 range. Deals an amount of damage inversely proportional to remaining HP.
//
// - Erkos
//   - Flame Ball : hits a 5x5 (circle) up to 4 range.
//   - Flame Wave : hits a 1-3-3-5-5 (wave) ahead. Deals 5 damage.
//   - Flame Rage : on the next turn, attacks deal +2 dmg. Stacks. Can't attack on this turn.
//   - Flame Soul : selects an enemy up to 1 range. Deals massive damage (20?).
//   - Flame Nova : loses 30 HP. Deals massive damage in a 11x11 circle (20?).
// 
// - Croni
//   - Shadow Doll : places a doll in empty tile for up to 8 range, blocking the way until the end of the turn.
//   - Shadow Ball : launches a ball that travels up to 8 tiles ahead, dealing high damage to first enemy hit.
//   - Shadow Flux : after a delay, hits a 3x3 (square) in up to 8 range for high damage.
//   - Shadow Trap : places a trap in a secret position; activate to reveal and stun in a 3x3 (circle).
//   - Shadow Bond : loses half hp. Can't attack on this turn. Can't use on next turn. If Croni dies on this turn, takes the killer with her.
//
// - Snarch
//   - Quick Shot      : hits a selected enemy up to 5 range.
//   - Piercing Bolt   : hits all enemies in a 5x1 (line) ahead.
//   - Explosive Arrow : hits up to 2 3x3 (circles) up to 5 range.
//   - Ballista        : mounts/dismounts from a ballista. Can't attack on this turn. While mounted, can't move and attacks range increase to 12.
// 
// - Sirpix
//   - Stealth Clone : creates a stealth in up to 3 range. If already created, moves it 3 steps. 
//   - Stealth Swap  : reveals your stealth clone's position. If it is an empty tile, swaps with it.
//   - Killing Edge  : hits a 3x3 (square) around.
// 
// - Kenlua
//   - Dodge : select 4 tiles up to 32 range. Prevent all damage from enemies standing on those tiles during this turn.
//   - Slice : hits a 3x3 (square) around, dealing damage. 
//   - Haste : moves 4 steps. 
//   - Slash : hits a 1x1 (point) up to 1 range. Deals massive damage. If the hit lands, returns to the position you were at the beginning of the turn.
// 
// - Flina
//   - Fly     : Select an position to pick an ally. Moves 4 steps, passing through enemies and cliffs. Afterwards, ally is moved to behind Flina.
//   - Lance   : hits a selected enemy up to 2 range.
//   - Ocarina : ...
// 
// - Stanci
//   - Heal    : selects an ally up to 4 range. Heals him/her.
//   - Shield  : selects an ally up to 4 range. Gives him/her armor.
//   - Restore : hits a 5x5 (circle) up to 4 range, healing allies inside.
//   - Light   : selects an enemy up to 4 range to deal damage.
// 
// - Zagatur
//   - Summon : selects an empty tile up to 4 range. Spawns a clone of Zagatur on it.
//   - Needle : Hits a 3x1 (line) ahead, dealing damage.
//   - Spikes : Hits a 3x3 (circle) around, dealing damage.
// 
// - Agdris
//   - Silence : selects up to two enemies up to 12 range. They can't attack on this turn.
//   ? Protect : selects up to two allies up to 12 range. Grants him/her 10 armor.
//   - Memento : dies. Enemies can't move or attack on this turn.
// 
// - Mewru
//   - Psychock    : hits a 3x3 (circle) up to 5 range, dealing damage.
//   - Telekinesis : pushes enemies in a 1-3-5 (wave) ahead.
//   - Teleport    : selects an empty location on the map. Moves to that location. 
//   - Absorb      : selects an enemy unit. During this turn, damage dealt by this unit to Mewru heals instead.
// 
// ## Move Priority
// 
// <<Instant: 0>>
// - Croni Shadow Trap (activate)
// - Agdris Silence
// - Agdris Memento
//
// <<SelfCast: 16>>
// - Sirpix Stealth Clone
// - Snarch Ballista
// - Erkos Flame Rage
// - Gonk Endure
// - Gonk Breath
// - Gonk Counter
// - Gonk Empathy 
// - Tophoro Earth Root
// - Mewru Absorb
// - Croni Shadow Bond
// 
// <<PointAndClick: 64>>
// - Tophoro Earth Lock
// - Stanci Shield
// - Stanci Heal
// - Kenlua Haste
// - Kenlua Slice
// - Sirpix Stealth Swap
// - SirPix Killing Edge
// - Stanci Light
// - Snarch Quick Shot
// - Flina Lance
// - Erkos Flame Soul
// - Gonk Shatter
//
// <<TerrainControl: 112>>
// - Tophoro Earth Wall
// - Croni Shadow Doll
//
// - <<Walk: 128>>
// - Kenlua Walk
// - Sirpix Walk
// - Flina Walk
// - Snarch Walk
// - Erkos Walk
// - Stanci Walk
// - Croni Walk
// - Gonk Walk
// - Tophoro Walk
// - Agdris Walk
// - Mewru Walk
// - Zagatur Walk
//
// <<Post-Walk: 160>>
// - Flina Fly
// - Mewru Teleport
// - Kenlua Dodge
// 
// <<Skillshot: 176>>
// - Tophoro Earth Pull
// - Tophoro Earth Slam
// - Kenlua Slash
// - Snarch Piercing Bolt
// - Snarch Explosive Arrow
// - Erkos Flame Wave
// - Erkos Flame Ball
// - Erkos Flame Nova
// - Zagatur Needles
// - Zagatur Spikes
// - Mewru Telekinesis
// - Mewru Psychock
// - Croni Shadow Flux
// - Croni Shadow Ball
// - Stanci Restore
//
// <<EndTurn: 224>>
// - Croni Shadow Trap (place)
// - Zagatur Summon

// Testing pull action
def kaelin:
  dup casts_write     = (write ~8)
  dup board_write     = (write ~10)
  dup step            = step
  dup earth_pull      = earth_pull
  dup flame_wave      = flame_wave
  dup print_board     = print_board
  dup board_inter     = board_interact
  dup flame_ball      = flame_ball
  dup flame_soul      = flame_soul
  dup flame_nova      = flame_nova
  dup exec_turn       = exec_turn
  dup shadow_doll     = shadow_doll
  dup shadow_flux     = shadow_flux
  dup quick_shot      = quick_shot
  dup piercing_bolt   = piercing_bolt
  dup explosive_arrow = explosive_arrow
  dup earth_slam  = earth_slam
  dup erkos_walk      = erkos_walk
  let casts       = empty_casts

  # let board = new_board

    // Move Croni to below Tophoro
    let board = (step [29,1] [0,1] board)
    let board = (step [29,2] [0,1] board)
    let board = (step [29,3] [1,0] board)

    // Throws a flame ball at Erkos and Gonk
    //let board = (flame_ball [15,15] board)

    // Performs an example turn where Tophoro performs Earth Pull down
    //let casts = (casts_write EARTH_PULL [[30,1], {t}(t [0,1])] casts)
    //get [board, anims] = (exec_turn casts board)

    //let board = (piercing_bolt [24,1] [1,0] board)
    //let board = (quick_shot [1,30] (Cons RIGHT (Cons RIGHT (Cons RIGHT Nil))) board)
    //let board = (erkos_walk [2,30] (Cons [1,0] (Cons [1,0] (Cons [0,-1] Nil))) board)
    //let dirs8 = (Cons UP (Cons UP (Cons [0,0] (Cons [0,0] (Cons [0,0] (Cons [0,0] (Cons [0,0] (Cons [0,0] Nil))))))))
    let dirs5a = (Cons UP (Cons UP (Cons RIGHT (Cons RIGHT (Cons RIGHT Nil))))) 
    let dirs5b = (Cons UP (Cons UP (Cons UP (Cons LEFT (Cons LEFT Nil))))) 
    //let dirs3 = (Cons RIGHT (Cons RIGHT (Cons RIGHT Nil)))
    //let board = (shadow_flux [15,31] dirs board)
    //let board = (shadow_doll [15,31] dirs board)
    let board = (explosive_arrow [15,31] dirs5a dirs5b board)

    (print_board board)
    //board

    //[(print_board board), anims]

// :::::::::::::::
// :: Direction ::
// :::::::::::::::

def RIGHT : [1 , 0] 
def DOWN  : [0 , 1] 
def LEFT  : [-1, 0] 
def UP    : [0 ,-1] 

// Transforms a direction [RIGHT, LEFT, UP, DOWN] into a vector that represents that position
def dir_to_vec: {a}
  cpy a = a
  if |a < 2|
  then:
    if |a == 0|
    then: [ 1,  0]
    else: [ 0,  1]
  else:
    if |a == 2|
    then: [-1,  0]
    else: [ 0, -1]

// ::::::::::
// :: Side ::
// ::::::::::

def WHITE : 0
def BLACK : 1
def BOARD : 2

def eql_side: {a b}
  |a == b|

def side_to_icon: {side}
  cpy side = side
  if |side == WHITE|
  then: (to_chars "O")
  else: if |side == BLACK|
    then: (to_chars "X")
    else: (to_chars "B")

// ::::::::::::
// :: Heroes ::
// ::::::::::::

def TOPHORO : 0
def GONK    : 1
def ERKOS   : 6
def CRONI   : 7
def SNARCH  : 8
def SIRPIX  : 12
def KENLUA  : 13
def FLINA   : 14
def STANCI  : 18
def ZAGATUR : 24
def AGDRIS  : 25
def MEWRU   : 26

def Tophoro : {side} (Unit side TOPHORO 120)
def Gonk    : {side} (Unit side GONK     90)
def Erkos   : {side} (Unit side ERKOS    40)
def Croni   : {side} (Unit side CRONI    40)
def Snarch  : {side} (Unit side SNARCH   60)
def Sirpix  : {side} (Unit side SIRPIX   60)
def Kenlua  : {side} (Unit side KENLUA   60)
def Flina   : {side} (Unit side FLINA    60)
def Stanci  : {side} (Unit side STANCI   40)
def Zagatur : {side} (Unit side ZAGATUR  10)
def Agdris  : {side} (Unit side AGDRIS   20)
def Mewru   : {side} (Unit side MEWRU    20)

def hero_name:
  let hero00 = (to_chars "Tophoro ")
  let hero01 = (to_chars "Gonk    ")
  let hero02 = (to_chars "Missna  ")
  let hero03 = (to_chars "Missna  ")
  let hero04 = (to_chars "Missna  ")
  let hero05 = (to_chars "Missna  ")
  let hero06 = (to_chars "Erkos   ")
  let hero07 = (to_chars "Croni   ")
  let hero08 = (to_chars "Snarch  ")
  let hero09 = (to_chars "Missna  ")
  let hero10 = (to_chars "Missna  ")
  let hero11 = (to_chars "Missna  ")
  let hero12 = (to_chars "Sirpix  ")
  let hero13 = (to_chars "Kenlua  ")
  let hero14 = (to_chars "Flina   ")
  let hero15 = (to_chars "Missna  ")
  let hero16 = (to_chars "Missna  ")
  let hero17 = (to_chars "Missna  ")
  let hero18 = (to_chars "Stanci  ")
  let hero19 = (to_chars "Missna  ")
  let hero20 = (to_chars "Missna  ")
  let hero21 = (to_chars "Missna  ")
  let hero22 = (to_chars "Missna  ")
  let hero23 = (to_chars "Missna  ")
  let hero24 = (to_chars "Zagatur ")
  let hero25 = (to_chars "Agdris  ")
  let hero26 = (to_chars "Mewru   ")
  let hero27 = (to_chars "Missna  ")
  let hero28 = (to_chars "Missna  ")
  let hero29 = (to_chars "Missna  ")
  let hero30 = (to_chars "Missna  ")
  let hero31 = (to_chars "Missna  ")
  let quad00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]
  let quad01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]
  let quad02 = [[[hero16,hero17],[hero18,hero19]],[[hero20,hero21],[hero22,hero23]]]
  let quad03 = [[[hero24,hero25],[hero26,hero27]],[[hero28,hero29],[hero30,hero31]]]
  let heroes = [[quad00,quad01],[quad02,quad03]]
  dup take   = (take ~5)
  # {hero} snd (take hero NilF heroes)

def hero_icon:
  let hero00 = (to_chars "To")
  let hero01 = (to_chars "Go")
  let hero02 = (to_chars "??")
  let hero03 = (to_chars "??")
  let hero04 = (to_chars "??")
  let hero05 = (to_chars "??")
  let hero06 = (to_chars "Er")
  let hero07 = (to_chars "Cr")
  let hero08 = (to_chars "Sn")
  let hero09 = (to_chars "??")
  let hero10 = (to_chars "??")
  let hero11 = (to_chars "??")
  let hero12 = (to_chars "Sr")
  let hero13 = (to_chars "Kl")
  let hero14 = (to_chars "Fl")
  let hero15 = (to_chars "??")
  let hero16 = (to_chars "??")
  let hero17 = (to_chars "??")
  let hero18 = (to_chars "St")
  let hero19 = (to_chars "??")
  let hero20 = (to_chars "??")
  let hero21 = (to_chars "??")
  let hero22 = (to_chars "??")
  let hero23 = (to_chars "??")
  let hero24 = (to_chars "Za")
  let hero25 = (to_chars "Ag")
  let hero26 = (to_chars "Me")
  let hero27 = (to_chars "??")
  let hero28 = (to_chars "??")
  let hero29 = (to_chars "??")
  let hero30 = (to_chars "??")
  let hero31 = (to_chars "??")
  let quad00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]
  let quad01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]
  let quad02 = [[[hero16,hero17],[hero18,hero19]],[[hero20,hero21],[hero22,hero23]]]
  let quad03 = [[[hero24,hero25],[hero26,hero27]],[[hero28,hero29],[hero30,hero31]]]
  let heroes = [[quad00,quad01],[quad02,quad03]]
  dup take   = (take ~5)
  # {hero} snd (take hero NilF heroes)

// :::::::::::
// :: Piece ::
// :::::::::::

def Air:
  {Air Wall Cliff Throne Unit}
  Air

def Wall:
  {Air Wall Cliff Throne Unit}
  Wall

def Cliff:
  {Air Wall Cliff Throne Unit}
  Cliff

def Throne: {side}
  {Air Wall Cliff Throne Unit}
  (Throne side)

def Unit: {hero side hp}
  {Air Wall Cliff Throne Unit}
  (Unit hero side hp)

def piece_icon:
  dup hero_icon = hero_icon
  # {piece}
    let case_air    = (to_chars " .")
    let case_wall   = (to_chars " W")
    let case_cliff  = (to_chars " C")
    let case_throne = {side} (to_chars " T")
    let case_unit   = {side hero hp} (hero_icon hero)
    (piece case_air case_wall case_cliff case_throne case_unit)

def piece_info:
  dup hero_name = hero_name
  # {piece}
    let case_air    = [Air, NilF]
    let case_wall   = [Wall, NilF]
    let case_cliff  = [Cliff, NilF]
    let case_throne = {side} [(Throne side), NilF]
    let case_unit   = {side hero hp}
      cpy hero = hero
      cpy hp   = hp
      cpy side = side
      let val  = (Unit side hero hp)
      let info =
        (concat (hero_name hero) // Hero name
        (concat (to_chars ": ")
        (concat (ConsF (box_byte (num_to_char ||hp / 100| % 10|)) NilF) // HP
        (concat (ConsF (box_byte (num_to_char ||hp /  10| % 10|)) NilF) // HP
        (concat (ConsF (box_byte (num_to_char ||hp /   1| % 10|)) NilF) // HP
        (concat (to_chars " hp -- ")
        (concat (if side [(to_chars "black"),(to_chars "white")])
                (ConsF #10 NilF))))))))
      [val, info]
    (piece case_air case_wall case_cliff case_throne case_unit)

def piece_cpy_with: {fn piece}
  let case_air    = {fn} [Air, (fn Air)]
  let case_wall   = {fn} [Wall, (fn Wall)]
  let case_cliff  = {fn} [Cliff, (fn Cliff)]
  let case_throne = {side} {fn}
    cpy side = side
    [(Throne side), (fn (Throne side))]
  let case_unit = {side hero hp} {fn}
    cpy side = side
    cpy hero = hero
    cpy hp   = hp
    [(Unit side hero hp), (fn (Unit side hero hp))]
  (piece case_air case_wall case_cliff case_throne case_unit fn)

def piece_is_hero: {hero piece}
  let case_air    = 0
  let case_wall   = 0
  let case_cliff  = 0
  let case_throne = {a_side} 0
  let case_unit   = {a_side a_hero a_hp} |a_hero == hero|
  (piece case_air case_wall case_cliff case_throne case_unit)

// "a" and "b" are side positions. The function checks if they can swap their position, that is, simulate a walk, and returns:
// - The same position: if they can't interact with each other.
// - Inverted position: the elements interacted and one now occupies the position of the other.
def a_step_to_b: {a b}
  let case_a_air      = {b} [Air, b]
  let case_a_wall     = {b} [Wall, b]
  let case_a_cliff    = {b} [Cliff, b]
  let case_a_throne   = {a_side} {b} [(Throne a_side), b]
  let case_a_unit     = {a_side a_hero a_hp} {b}
    let case_b_air    = {a_side a_hero a_hp}
      let a_val       = (Unit a_side a_hero a_hp)
      let b_val       = Air
      [b_val, a_val]
    let case_b_wall   = {a_side a_hero a_hp}
      let a_val       = (Unit a_side a_hero a_hp)
      let b_val       = Wall
      [a_val, b_val]
    let case_b_cliff  = {a_side a_hero a_hp}
      let a_val       = (Unit a_side a_hero a_hp)
      let b_val       = Cliff
      [a_val, b_val]
    let case_b_throne = {b_side} {a_side a_hero a_hp}
      let a_val       = (Unit a_side a_hero a_hp)
      let b_val       = (Throne b_side)
      [a_val, b_val]
    let case_b_unit   = {b_side b_hero b_hp} {a_side a_hero a_hp}
      cpy a_side      = a_side
      cpy b_side      = b_side
      let a_val       = (Unit a_side a_hero a_hp)
      let b_val       = (Unit b_side b_hero b_hp)
      let can_pass    = (eql_side a_side b_side)
      let then_swap   = [{a b}[b,a],{a b}[a,b]]
      (if can_pass then_swap a_val b_val)
    (b case_b_air case_b_wall case_b_cliff case_b_throne case_b_unit a_side a_hero a_hp)
  (a case_a_air case_a_wall case_a_cliff case_a_throne case_a_unit b)

// :::::::::::
// :: Board ::
// :::::::::::

def new_board:
  let O   = Air
  let a   = (Gonk WHITE)
  let b   = (Erkos WHITE)
  let c   = (Kenlua WHITE)
  let d   = (Mewru WHITE)
  let e   = (Tophoro BLACK)
  let f   = (Croni BLACK)
  let g   = (Stanci BLACK)
  let h   = (Flina BLACK)
  let W   = Wall
  let C   = Cliff
  let x   = (Throne WHITE)
  let y   = (Throne BLACK)
  let r00 = [[[[[W,W],[W,W]],[[W,W],[W,O]]],[[[O,W],[W,O]],[[O,O],[O,W]]]],[[[[W,O],[O,O]],[[O,W],[W,O]]],[[[O,W],[W,W]],[[y,W],[W,W]]]]]
  let r01 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[h,g]],[[O,f],[e,W]]]]]
  let r02 = [[[[[W,W],[W,W]],[[W,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,C],[O,O]],[[O,O],[O,W]]]]]
  let r03 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
  let r04 = [[[[[W,O],[W,W]],[[W,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,C],[O,O]],[[O,O],[O,W]]]]]
  let r05 = [[[[[W,O],[O,W]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
  let r06 = [[[[[W,W],[W,W]],[[W,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,O]],[[O,O],[W,W]]]]]
  let r07 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]

  let r08 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
  let r09 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
  let r10 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
  let r11 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
  let r12 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
  let r13 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
  let r14 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
  let r15 = [[[[[C,C],[C,C]],[[C,C],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[C,C],[C,C]],[[C,C],[C,C]]]]] // MID

  let r16 = [[[[[C,C],[C,C]],[[C,C],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[C,C],[C,C]],[[C,C],[C,C]]]]] // MID
  let r17 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
  let r18 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
  let r19 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
  let r20 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
  let r21 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
  let r22 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
  let r23 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]

  let r24 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
  let r25 = [[[[[W,W],[O,O]],[[O,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]]
  let r26 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
  let r27 = [[[[[W,O],[O,O]],[[O,O],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[W,W],[W,W]]]]]
  let r28 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,O],[O,W]]]]]
  let r29 = [[[[[W,O],[O,O]],[[O,O],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,W],[W,W]]]]]
  let r30 = [[[[[W,a],[b,O]],[[c,d],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,W],[O,W]]]]]
  let r31 = [[[[[W,W],[W,x]],[[W,W],[W,O]]],[[[O,W],[W,O]],[[O,O],[O,W]]]],[[[[W,O],[O,O]],[[O,W],[W,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]]
  [[[[[r00,r01],[r02,r03]],[[r04,r05],[r06,r07]]],[[[r08,r09],[r10,r11]],[[r12,r13],[r14,r15]]]],
   [[[[r16,r17],[r18,r19]],[[r20,r21],[r22,r23]]],[[[r24,r25],[r26,r27]],[[r28,r29],[r30,r31]]]]]

// Simulates an index in an array of 1024 elements (32x32 map).
// x: column
// y: line 
def board_index: {pos}
  get [x,y] = pos
  ||y * 32| + x|

def board_interact:
  dup write = (write ~10)
  dup take  = (take ~10)
  # {a_pos b_pos fun board}
    cpy a_idx         = (board_index a_pos)
    cpy b_idx         = (board_index b_pos)
    get [board,a_val] = (take a_idx Air board)
    get [board,b_val] = (take b_idx Air board)
    get [a_val,b_val] = (fun a_val b_val)
    let board         = (write a_idx a_val board)
    let board         = (write b_idx b_val board)
   board 

// Apply a function to a board piece
def board_apply:
  dup write = (write ~10)
  dup take  = (take ~10)
  # {pos fun board}
    cpy p_idx       = (board_index pos)
    get [board,val] = (take p_idx Air board)
    let p_update    = (fun val)
    let board       = (write p_idx p_update board)
  board

def print_board:
  dup fold = (fold_array ~10)
  dup piece_info = #piece_info
  dup piece_icon = #piece_icon
  # {board}
    dup piece_info = piece_info
    dup piece_icon = piece_icon
    let fold_node = {lft rgt}
      get [lft_info, lft_board] = lft
      get [rgt_info, rgt_board] = rgt
      [(concat lft_info rgt_info), (concat lft_board rgt_board)]
    let fold_leaf = {piece}
      get [piece, info] = (piece_info piece)
      [info, (piece_icon piece)]
    get [info, board] = (fold board #fold_node #fold_leaf)
    let board = (cons-every #64 #10 board)
    (from_chars (concat (ConsF 10 NilF) (concat info (concat board (ConsF 10 NilF)))))

// :::::::::::::
// :: Effects ::
// :::::::::::::

// Given a position and a direction to step forward, move the element (if is possible) and return the updated map
def step:
  dup inter = board_interact
  # {a_pos a_dxy board}
    get [a_pos0,a_pos1] = (vec2_cpy a_pos)
    let b_pos           = (vec2_add a_pos0 a_dxy)
    (inter a_pos1 b_pos a_step_to_b board)

def damage_visual_effect: {dmg piece}
  let case_air    = Cliff
  let case_wall   = Wall
  let case_cliff  = Cliff
  let case_throne = {side} (Throne side)
  let case_unit   = {side hero hp} (Unit side hero |hp - dmg|)
  (piece case_air case_wall case_cliff case_throne case_unit)

// TODO: 
// - check if the life of "piece" is bigger than the damage
def damage: {dmg piece}
  let case_air    = Air
  let case_wall   = Wall
  let case_cliff  = Cliff
  let case_throne = {side} (Throne side)
  let case_unit   = {side hero hp} (Unit side hero |hp - dmg|)
  (piece case_air case_wall case_cliff case_throne case_unit)

// TODO: Flip properties of a piece about move and attack
def stun: {piece}
  let case_air     = Air
  let case_wall    = Wall
  let case_cliff   = Cliff
  let case_throne  = {side} (Throne side)
  let case_unit    = {side hero hp} (Unit side hero hp)
  (piece case_air case_wall case_cliff case_throne case_unit)

// Stun enemies in a 3x3 (circle) around
def stun_small_circle:
  let area  = vec2_circle_b
  let hits  = {pos board} (board_apply pos stun board)
  (area #hits) 

// Checks if given position is a specific hero
def is_hero_at:
  dup board_with = (with ~10)
  # {pos hero board}
    (board_with (board_index pos) (piece_cpy_with (piece_is_hero hero)) board)

// Walks through a set of directions
def walk: {hero steps}
  dup hero       = hero
  dup is_hero_at = is_hero_at
  let walk       = {state}
    get [pos_dirs,board] = state
    get [pos,dirs]       = pos_dirs
    get [dirs,dir]       = (pop [0,0] dirs)
    get [pos,pos_cpy]    = (vec2_cpy pos)
    get [dir,dir_cpy]    = (vec2_cpy dir)
    let new_pos          = (vec2_add pos_cpy dir_cpy)
    get [pos,pos_cpy]    = (vec2_cpy pos)
    get [board,allow]    = (is_hero_at pos_cpy hero board)
    let board            = (if allow [step, {pos dir board}board] pos dir board)
    [[new_pos,dirs], board]
  dup walk = (steps #walk)
  # {pos dirs board}
    snd (walk [[pos,dirs],board])

// Walk effects of each hero
def erkos_walk  : (walk ERKOS ~3)
def snarch_walk : (walk SNARCH ~3)

// Using a path, goes from "pos" to "target position"
// - dirs : movement list to get into the desired position
// - pos  : initial position
def add_dirs: {mlen}
  dup move = (mlen {pos_dirs}
    get [pos,dirs] = pos_dirs
    get [dirs,dir] = (pop [0,0] dirs)
    [(vec2_add pos dir), dirs])
  # {pos dirs}
    fst (move [pos,dirs])

// Creates up to 3 earth walls in a 5x5 (circle) around.
// TODO: Add box
// TODO: Add range area
def earth_wall: {pos1 pos2 pos3 board}
  let case_air     = Wall
  let case_wall    = Wall
  let case_cliff   = Cliff
  let case_throne  = {side} (Throne side)
  let case_unit    = {side hero hp} (Unit side hero hp)
  let change_piece = {t} (t case_air case_wall case_cliff case_throne case_unit)
  let board = (board_apply pos1 change_piece board)
  let board = (board_apply pos2 change_piece board)
  let board = (board_apply pos3 change_piece board)
  board

// Slams enemies in a 3x3 (square) around, stunning him/her.
def earth_slam:
  let area  = vec2_circle_c
  let hits  = {pos board} (board_apply pos stun board)
  (area #hits) 

def earth_pull:
  dup step = step
  let area = (vec2_wave_in (ConsF #1 (ConsF #3 (ConsF #5 NilF))))
  let hits = {pos dxy board} (step pos dxy board)
  (area #hits)

// Hits a 1-3-3-5-5 (wave). Deals 5 damage.
def flame_wave:
  let area = (vec2_wave (ConsF #1 (ConsF #3 (ConsF #3 (ConsF #5 (ConsF #5 NilF))))))
  let hits = {pos board} (board_apply pos (damage 5) board)  
  (area #hits)
  
// Hits a 5x5 (circle). Deals 5 damage.
// TODO: add 4 range
def flame_ball:
  let area = vec2_circle_e
  //let hits = {pos board} (board_apply pos (damage 5) board)
  let hits = {pos board} (board_apply pos (damage_visual_effect 5) board)
  (area #hits)

// Selects an enemy up to 1 range. Deals massive damage (20?)
def flame_soul: {pos dir}
  let t_pos = (vec2_add pos dir)
  //let hits  = {board} (board_apply t_pos (damage 20) board)
  let hits = {board} (board_apply t_pos (damage_visual_effect 21) board)
  hits

// Deals massive damage in a 11x11 circle (20?)
def flame_nova:
  let area = vec2_circle_j
  let hits = {pos board} (board_apply pos (damage 20) board)
  //let hits = {pos board} (board_apply pos (damage_visual_effect 20) board)
  (area #hits)

// Places a doll in an empty tile
def shadow_doll:
  dup add_dirs = (add_dirs ~9)
  let case_air     = Wall
  let case_wall    = Wall
  let case_cliff   = Cliff
  let case_throne  = {side} (Throne side)
  let case_unit    = {side hero hp} (Unit side hero hp)
  let change_piece = {t} (t case_air case_wall case_cliff case_throne case_unit)
  # {pos dirs board}
    (board_apply (add_dirs pos dirs) change_piece board)

// TODO: launches a ball that travels up to 8 tiles ahead, dealing high damage to first enemy hit
//def shadow_ball: 

// Hits a 3x3 (square) with range 8 for high damage (15?).
def shadow_flux:
  dup add_dirs = (add_dirs ~9)
  let area = vec2_circle_c
  let hits = {pos board} (board_apply pos (damage_visual_effect 15) board) 
  # {pos dirs board}
    (area #hits (add_dirs pos dirs) board)

// TODO: Loses half hp. Can't attack on this turn. Can't use on next turn. If Croni dies on this turn, takes the killer with her.
//def shadow_bond: {side hero hp}

// Hits a selected enemy up to 3 range. Deals 5 damage.
def quick_shot:
  dup add_dirs = (add_dirs ~4)
  # {pos dirs board}
    (board_apply (add_dirs pos dirs) (damage_visual_effect 3) board)

// Hits all enemies in a 5x1 (line) ahead. Deals 3 damage.
def piercing_bolt:
  let area = (vec2_wave (ConsF #1 (ConsF #1 (ConsF #1 (ConsF #1 (ConsF #1 NilF))))))
  let hits = {pos board} (board_apply pos (damage_visual_effect 3) board)
  (area #hits) 

// Explosive Arrow : hits up to 2 3x3 (circles) up to 5 range. Deals 2 damage.
def explosive_arrow:
  dup add_dirs = (add_dirs ~6)
  let area = vec2_circle_b
  let hits = {pos board} (board_apply pos (damage_visual_effect 2) board)
  # {pos dirs1 dirs2 board}
    get [pos1,pos2] = (vec2_cpy pos)
    let t_pos1 = (add_dirs pos1 dirs1)
    let t_pos2 = (add_dirs pos2 dirs2)
    let board  = (area #hits t_pos1 board)
    let board  = (area #hits t_pos2 board)
    board

// TODO: mounts/dismounts from a ballista. Can't attack on this turn. While mounted, can't move and attacks range increase to 12.
//def ballista:

// Hits a 3x3 (square) around. Deals 3 damage.
def killing_edge:
  let area = vec2_circle_c
  let hits = {pos board} (board_apply pos (damage_visual_effect 3) board)
  (area #hits)

// Select 4 tiles up to 32 range. Prevent all damage from enemies standing on those tiles during this turn.
// TODO: Change function applied to the positions to "silence"
def dodge: 
  dup add_dirs = (add_dirs ~32)
  # {pos dirs1 dirs2 dirs3 dirs4 board}
  get [pos1,pos2] = (vec2_cpy pos)
  get [pos3,pos4] = (vec2_cpy pos1)
  get [pos5,pos6] = (vec2_cpy pos3)
  let case_air     = Air
  let case_wall    = Wall
  let case_cliff   = Cliff
  let case_throne  = {side} (Throne side)
  let case_unit    = {side hero hp} (Unit side hero hp)
  let board = (board_apply (add_dirs pos2 dirs1) (damage_visual_effect 1) board)
  let board = (board_apply (add_dirs pos4 dirs1) (damage_visual_effect 1) board)
  let board = (board_apply (add_dirs pos5 dirs1) (damage_visual_effect 1) board)
  let board = (board_apply (add_dirs pos6 dirs1) (damage_visual_effect 1) board)
  board

// Hits a 3x3 (square) around. Deals 8 damage.
def slice_area:
  let area = vec2_circle_c
  let hits = {pos board} (board_apply pos (damage_visual_effect 8) board)
  (area #hits)

//Haste : moves 4 steps. 
//def haste: {mov}
//  let path = mov
   



// :::::::::::
// :: Moves ::
// :::::::::::

def PASS       : 0
def EARTH_PULL : 176

// TODO: we need an array init function that doesn't add 2 levels
def empty_casts:
  let a = [0,0]
  let b = [a,a]
  let c = [b,b]
  let d = [c,c]
  let e = [d,d]
  let f = [e,e]
  let g = [f,f]
  let h = [g,g]
  [h,h]

def exec_turn:
  // Config
  dup casts_take  = (take ~8)
  dup casts_write = (write ~8)
  dup board_take  = (take ~10)
  dup board_write = (write ~10)

  // Function
  # {casts board}

    // Utils
    let get_cast  = {skill casts} (casts_take skill 0 casts)
    let get_piece = {pos board} (board_take (board_index pos) Air board)

    // Animations
    let anims = Nil

    // EARTH_PULL
    // TODO: abstract this logic in a single `hero_use_skill` function
    get [casts,cast]  = (get_cast EARTH_PULL casts)
    get [pos,args]    = cast
    get [pos,pos0]    = (vec2_cpy pos)
    get [board,piece] = (get_piece pos0 board)
    get [piece,allow] = (piece_cpy_with (piece_is_hero TOPHORO) piece)
    get [pos,pos0]    = (vec2_cpy pos)
    get [board,anims] = 
      ( if allow
        then: {board anims}
          let board = (args (earth_pull pos0) board)
          let anims = (Cons "Tophoro used Earth Pull." anims)
          [board, anims]
        else: {board anims}
          [board, (Cons "Invalid use of Earth Pull." anims)]
        board anims)
    let board = (board_write (board_index pos) piece board)

    // Result
    [board, anims]

//W W W W W W W . . W W . . . . W W . . . . W W . . W W W T W W W
//W . . W . . W . . . . . . . . . . . . . . . . . . W X X . X X W
//W W W W W . W . . . . . . . . . . . . . . . . . . C . . . . . W
//W . . W . . W . . . . . . . . . . . . . . . . . . W . . . . . W
//W . W W W W W . . . . . . . . . . . . . . . X . . C . . . . . W
//W . . W . . . . . . . . . . . . . . . . X X X X X W . . . . . W
//W W W W W . W . . . . . . . . . . . . X X X X X X W W . . . W W
//. . . . . . . . . . . . . X X . . . X X X X X X X X X . . . . .
//. . . . . . . . . . . X X X X . . . X X X X X X X X X . . . . .
//W . . . . . . . . E X X X X X . . X X X X X T X X X X X . . . W
//W . . . . . . . . . . X X X X . . . X X X X X X X X X . . . . W
//W . . . . . . . . . . . . X X . . . X X X X X X X X X . . . . W
//. . . . . . . . . . . . . . . . . . . X X X X X X X . . . . . .
//. . . . . . . . . . . . . . . . C . . . X X X X X . . . . . . .
//. . . . . . . . . . . . . . X X S . . . . . X . . . . . . . . .
//C C C C C C C . . . . . . X X X X X . . . . . . C C C C C C C C
//C C C C C C C . . . . E . X X T X X . . . . . . C C C C C C C C
//. . . . . . . . . . . . . X X X X X . . . . . . . . . . . . . .
//. . . . . . . . . . . . . . X X X . . . . . . . . . . . . . . .
//. . . . . . . . . . . . . . . . . . . . . X X X . . . . . . . .
//W . . . . . . . . . . . . . . . . . . . . X T X . . . . . . . W
//W . . . . . . . . . . K . . . . . X . . . X X X . . . . . . . W
//W . . . . . . . . . . . . . . . X X . . . . . . . . . . . . . W
//. . . . O O . . . . . . . . T X X X . . . . . . . . . . . . . .
//. . . . . . . . . . . . . . . . X X . . . . . . . . . . . . . .
//W W . . . W W . . . . . . . . . . X . . . . . . . W W W W W W W
//W . . . . . W . . . . . . . . . . . . . . . . . . W . . . . . W
//W . . . . . C . . . . . . . . . . . . . . . . . . W . W W W W W
//W . . . . . W . . . . . . . . . . . . . . . . . . W . W . . . W
//W . . . . . C . . . . . . . . . . . . . . . . . . W . W . W W W
//W O . K . O W . . . . . . . . . . . . . . . . . . W . W . W . W
//W W W T W W W . . W W . . . . W W . . . . W W . . W W W W W W W"

//W W W W W W W . . W W . . . . W W . . . . W W . . W W W T W W W
//W . . W . . W . . . . . . . M . . . . . . . . . . W X X . X X W
//W W W W W . W . . . . . . M M M . . . . . . . . . C . . . . . W
//W . . W . . W . . . . . M M M M M . . . . . . . . W . . . . . W
//W . W W W W W . . . . M M M M M M M . . . . . . . C . . . . . W
//W . . W . . . . . . M M M M O M M M M . . . . . . W . . . . . W
//W W W W W . W . . M M M M O O O M M M M . . . . . W W . . . W W
//. . . . . . . . M M M M O O O O O M M M M . . . . . . . . . . .
//. . . . . . . M M M M O O O O O O O M M M M . . . . . X . . . .
//W . . . . . M M M M O O O O 4 O O O O M M M M . . . X X X . . W
//W . . . . M M M M O O O O 4 4 4 O O O O M M M M . . . X . . . W
//W . . . M M M M O O O O 4 4 4 4 4 O O O O M M M M . . . . . . W
//. . . M M M M O O O O 4 4 4 4 4 4 4 O O O O M M M M . . . . . .
//. . M M M M O O O O 4 4 4 4 C 4 4 4 4 O O O O M M M M . . . . .
//. . . M M M M O O O O 4 4 4 4 4 4 4 O O O O M M M M . . . . . .
//C C C C C C C M O O O O 4 4 4 4 4 O O O O M M M C C C C C C C C
//C C C C C C C M M O O O O 4 4 4 O O O O M M M M C C C C C C C C
//. . . . . . M M M M O O O O 4 O O O O M M M M . . . . . . . . .
//. . . . . . . M M M M O O O O O O O M M M M . . . . . . . . . .
//. . . . . . . . M M M M O O O O O M M M M . . . . . . . . . . .
//W . . . . . . . . M M M M O O O M M M M . . . . . . . . . . . W
//W . . . . . . . . . M M M M O M M M M . . . C . . . . . . . . W
//W . . . . . . . . . . M M M M M M M . . . . 4 . . . . . . . . W
//. . . . O O . . . . . . M M M M M . . . . . 4 . . . . . . . . .
//. . . . . . . . . . . . . M M M . . . . . . 4 . . . . . . . . .
//W W . . . W W . . . . . . . M . . . . . . . 4 . . W W W W W W W
//W . . . . . W . . . . . . . . . . . . . . . O . . W . . . . . W
//W . . . . . C . . . . . . . . . . . . . . . O . . W . W W W W W
//W . . . . . W . . . . . . . . . . . . . . . O . . W . W . . . W
//W . . . . . C . . . . . . . . . . . . . . . O . . W . W . W W W
//W O . . . O W . . . . . . . . . . . . . . . . . . W . W . W . W
//W W W T W W W . . W W . . . . W W . . . . W W . . W W W W W W W"
